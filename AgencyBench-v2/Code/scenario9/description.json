{
    "subtask_count": 5,
    "subtask1": "Query:\n**Subtask 1: Docker Sandbox Management and Repository Cloning**\n\nImplement isolated execution environment using Docker:\n\n1. Create Docker sandbox manager in `app/sandbox/docker_manager.py`:\n   - Implement `create_container(image: str, env: Optional[Dict]) -> str` function\n   - Implement `cleanup(container_id: str) -> None` function\n   - Implement `clone_repo(container_id: str, repository_full: str) -> str` function\n   - Use docker SDK to create and manage containers\n   - Select appropriate base image (e.g., python:3.11-slim)\n   - Configure container with development tools (Python, Git, etc.)\n2. Implement container lifecycle management:\n   - Create container with workspace directory mount\n   - Start and stop containers as needed\n   - Track container IDs in session records\n   - Remove containers on cleanup\n3. Integrate repository cloning into sandbox:\n   - Clone target repository into container workspace (/workspace/repo)\n   - Configure Git user and email for commits\n   - Handle cloning errors gracefully\n4. Implement concurrency limiter in `app/limits/concurrency.py`:\n   - Implement `get_max_concurrent() -> int` function (returns 2)\n   - Implement `can_start_new_agent() -> bool` function\n   - Track active agent sessions in database\n   - Enforce maximum 2 concurrent agents\n   - Queue new tasks when limit reached\n   - Return appropriate status when limit exceeded\n5. Add timeout and duplicate prevention:\n   - Track session start time\n   - Enforce 1-hour maximum execution time\n   - Check for existing active session for same (repository, issue_number)\n   - Reject duplicate processing attempts\n\n**Acceptance Criteria:**\n- Docker containers are created with correct base image and configuration\n- Container lifecycle (create, start, stop, remove) works correctly\n- Repositories are cloned into container workspace successfully\n- Concurrency limit of 2 is enforced and tracked\n- Timeout mechanism cancels sessions after 1 hour\n- Duplicate issue processing is prevented\n- Container IDs are stored in session records",
    "subtask2": "Query:\n**Subtask 2: SmolAgents Initialization and Tool Implementation**\n\nSet up SmolAgents execution engine with sandbox tools:\n\n1. Install and configure SmolAgents Code Agent Core in `app/agent/smol.py`:\n   - Implement `run_planning_step(session_id: str, repository: str, issue_title: str, issue_body: str) -> Tuple[str, str]` function\n   - Install smolagents package and dependencies\n   - Initialize agent with OpenAI-compatible LLM client\n   - Configure API endpoint and authentication using LLM_API_KEY and LLM_BASE_URL\n   - Set up model selection based on task complexity\n2. Implement `container_shell` tool:\n   - Execute shell commands in Docker container\n   - Return command output and exit codes\n   - Handle command errors appropriately\n3. Implement `container_fs` tool:\n   - File read operations from container workspace\n   - File write, replace, insert, and append operations\n   - Validate file paths and handle errors\n4. Implement `container_git` tool:\n   - Git branch creation and switching\n   - Commit changes with messages\n   - Push branches to remote repository\n5. Implement `code_search` tool:\n   - Semantic code search within repository\n   - Search by pattern or semantic query\n   - Return matching code snippets with context\n\n**Acceptance Criteria:**\n- SmolAgents successfully initializes and connects to LLM\n- LLM client is configured with correct endpoint and authentication\n- container_shell tool executes commands and returns results\n- container_fs tool performs all file operations correctly\n- container_git tool handles branch, commit, and push operations\n- code_search tool finds relevant code snippets\n- All tools handle errors gracefully and return appropriate responses",
    "subtask3": "Query:\n**Subtask 3: Agent Execution Workflow and State Management**\n\nBuild the core agent execution system with state tracking:\n\n1. Implement agent execution workflow in `app/agent/runner.py`:\n   - Implement `run_agent(session_id: str, repository: str, issue_number: int) -> None` function\n   - Parse issue title and body to extract requirements\n   - Generate task prompt with repository context\n   - Initialize agent with appropriate tools\n   - Stream agent execution steps and tool calls\n   - Capture agent outputs and decisions\n2. Implement execution state management:\n   - Track state: `running`, `suspended`, `completed`, `failed`\n   - Update session status in database as state changes\n   - Persist state transitions with timestamps\n3. Add user input handling:\n   - Detect when agent requests user input\n   - Update session status to `suspended`\n   - Store input request in session document\n   - Resume execution when input provided via Issue comment or API\n4. Implement comprehensive logging:\n   - Log all agent activities to MongoDB\n   - Include tool calls, responses, and decisions\n   - Log state transitions with context\n   - Capture agent reasoning and outputs\n5. Add error detection and handling:\n   - Catch agent execution exceptions\n   - Update session status to `failed` on errors\n   - Log errors with full traceback\n   - Store error details in session\n\n**Acceptance Criteria:**\n- Agent execution workflow processes issues correctly\n- Task prompts include repository context and requirements\n- Agent execution steps are streamed and captured\n- Execution states are properly tracked and updated in database\n- Suspended state works with user input detection\n- Execution resumes correctly when input is provided\n- All agent activities are logged to MongoDB\n- Errors are caught, logged, and update session status appropriately",
    "subtask4": "Query:\n**Subtask 4: PR Creation Workflow and GitHub Operations Integration**\n\nImplement complete PR creation and GitHub interaction workflow:\n\n1. Implement PR creation workflow in `app/agent/code_agent.py`:\n   - Implement `run_code_agent(session_id: str, repository: str, issue_number: int, ...) -> None` function\n   - Implement `create_code_agent_tools(container_id: str, workdir: str) -> list` function\n   - Create feature branch from main/master\n   - Commit all changes made by agent\n   - Push branch to remote repository\n   - Create PR with descriptive title and body\n   - Extract PR URL and store in session\n2. Integrate github_operations tool:\n   - Create PR using GitHub CLI wrapper\n   - Post comments to original Issue with PR link\n   - Format PR description with issue context\n   - Handle PR creation errors gracefully\n3. Add PR metadata tracking:\n   - Store PR URL in session document\n   - Link PR to original issue number\n   - Track PR status (open, merged, closed)\n4. Implement error recovery and reporting:\n   - Catch PR creation failures\n   - Log errors with full context\n   - Post error summary to original Issue\n   - Update session status appropriately\n5. Add completion handling:\n   - Mark session as `completed` when PR is created\n   - Post success message to Issue\n   - Clean up resources (containers, temp files)\n   - Generate completion summary\n\n**Acceptance Criteria:**\n- Feature branches are created from main/master correctly\n- All agent changes are committed with appropriate messages\n- Branches are pushed to remote successfully\n- PRs are created with descriptive title and body\n- PR links are posted to original Issues\n- PR metadata is stored in session documents\n- Error recovery posts summaries to Issues\n- Completion handling cleans up resources properly\n- Session status reflects PR creation success or failure",
    "subtask5": "Query:\n**Subtask 5: Monitoring Web Interface with Real-time Log Streaming**\n\nCreate comprehensive monitoring dashboard with WebSocket support:\n\n1. Set up static file serving and HTML interface:\n   - Serve frontend assets from static directory\n   - Build HTML interface using Tailwind CSS and Shadcn/ui\n   - Create agent status dashboard (active/completed/failed sessions)\n   - Display session list with repository, issue number, status, timestamps\n   - Add Issue and PR links for each session\n2. Implement WebSocket server for real-time log streaming:\n   - Create `/ws/logs/{session_id}` endpoint\n   - Stream log entries from MongoDB as they are written\n   - Handle client connections and disconnections gracefully\n   - Support multiple clients viewing same session simultaneously\n3. Create REST API endpoints for monitoring in `app/http/monitor.py`:\n   - Implement router with `GET /api/sessions`: List all sessions with filtering (status, repository)\n   - Implement `GET /api/sessions/{session_id}`: Get detailed session information\n   - Implement `GET /api/sessions/{session_id}/logs`: Get historical logs\n   - Implement `POST /api/sessions/{session_id}/cancel`: Cancel running agent\n   - Implement `POST /api/sessions/{session_id}/resume`: Resume suspended agent with input\n4. Implement frontend WebSocket client:\n   - Connect to log stream when session is selected\n   - Display logs with color coding by level (info, debug, error, warning)\n   - Auto-scroll to latest log entry\n   - Show WebSocket connection status\n5. Add interactive features and styling:\n   - Cancel button for running agents\n   - Resume button with input dialog for suspended agents\n   - Filter and search sessions by repository, status, date\n   - Export logs as JSON or text file\n   - Responsive layout for desktop and mobile\n   - Status badges with color indicators\n   - Loading states and error messages\n\n**Acceptance Criteria:**\n- Monitoring interface displays all agent sessions correctly\n- WebSocket streams logs in real-time without noticeable delay\n- Log viewer shows formatted logs with proper color coding by level\n- Cancel functionality stops running agents and updates status\n- Resume functionality allows user input for suspended agents\n- API endpoints return correct data with proper error handling\n- Interface is responsive and visually polished\n- Multiple clients can simultaneously view same session logs\n- Filter and search functionality works correctly\n- Log export generates valid JSON and text files"
}

