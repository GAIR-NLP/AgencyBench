{
  "subtask_count": 5,
  "subtask1": "Query:\nConstruct a portrait Square Fit stage (640x960) that auto-resizes while keeping a 2:3 aspect ratio. Render a central `#playfield` with a visible `#target-area` box that the square must fit into, plus a prominent `#start-btn` labelled `Begin Fit` and a HUD `#hud` that explains tap/hold/release controls.\nDeliverables:\n- `index.html` linking `styles.css` and `app.js` with containers `#stage`, `#playfield`, `#target-area`, `#hud`, and `#start-btn` ready for Phaser 3 or DOM rendering.\n- `styles.css` styling the 640x960 portrait frame, center-aligned with safe padding, and a highlighted target box.\n- `app.js` exposing `window.app` with `initializeScene()` (idempotent) and `describeLayout()` returning bounding boxes for `playfield`, `target`, and `startButton` in viewport coordinates plus a `theme` string.\nRubric:\n- Layout fidelity: automation captures `layout.png` and confirms the stage is 640+/-6px tall with a 2:3 portrait ratio and centered within +/-6px horizontally; the target box sits near the vertical middle (y within 430-520px) and spans 140-220px per side.\n- Controls present: `#playfield`, `#target-area`, `#hud`, and `#start-btn` must exist; `#start-btn` should sit near the top-third (y around 140+/-30px) and call `initializeScene()` on load so describeLayout() is populated.\n- API contract: `describeLayout()` must include numeric `x`, `y`, `width`, `height` for `playfield` and `target`, and stay stable across two consecutive calls.",
  "subtask2": "Query:\nImplement the grow-and-release loop: holding inside the playfield should grow an on-screen square, and releasing evaluates whether it fits fully inside `#target-area`. Display attempt feedback inside `#status` (inside `#hud`) and highlight the last dropped square with `#last-attempt`. Provide automation hooks to avoid manual pressing.\nDeliverables:\n- Continue shipping only `index.html`, `styles.css`, and `app.js`; add a status line `#status` under the HUD.\n- Extend `window.app` with `debugState()` returning `{ attempts: [...], currentSize, lastResult }` and `simulateAttempt(durationMs, opts)` that programmatically runs a growth/release cycle without user clicks; include `setDemoSequence(sequence)` to preload attempts for evaluation.\nRubric:\n- Interaction: calling `simulateAttempt(650, { seed: 'fit' })` then `simulateAttempt(1200, { seed: 'overshoot' })` must append two entries to `debugState().attempts` with alternating `success` true/false while keeping `currentSize` reset between runs.\n- Status + highlight: After the first simulated attempt the `#status` text should read `Perfect fit!` (case-insensitive) and `#last-attempt` should wrap the landed square; after the second attempt `#status` should report a failure message and the highlight moves to the new square.\n- Continuity: describeLayout() from subtask1 remains valid and `initializeScene()` stays idempotent when called twice.",
  "subtask3": "Query:\nAdd configurable settings, level progression, and reskin/audio toggles while keeping the core loop intact. Include a `#settings` drawer with controls for grow time and target range, plus a mute toggle `#audio-toggle` and theme buttons. Persist progress to localStorage.\nDeliverables:\n- Maintain the three primary files; add UI nodes `#settings`, `#level-indicator`, `#audio-toggle`, and theme controls (class `.theme-option`).\n- Extend `window.app` with `applySettings({ growTimeMs, minTarget, maxTarget })`, `getSettings()`, `advanceLevel()`, `exportProgress()`, `setTheme(name)`, and `getAudioState()` returning `{ muted, music, sfx }`. Persist progress/config to `localStorage['squarefit-progress']`.\nRubric:\n- Settings: invoking `applySettings({ growTimeMs: 800, minTarget: 0.25, maxTarget: 0.6 })` updates `getSettings()` accordingly and writes a JSON blob to `squarefit-progress`.\n- Progression: `advanceLevel()` increments a numeric level in `debugState()` and clears the attempt buffer; `exportProgress()` mirrors the stored localStorage entry.\n- Reskin/audio: calling `setTheme('neon')` updates the reported `theme` in `describeLayout()` and visibly changes colors in `styles.css`; toggling `#audio-toggle` must flip `getAudioState().muted` while keeping music/sfx flags coherent.",
  "subtask4": "Query:\nIntroduce persistence controls and a lightweight backend imitation without adding new asset files. Add a `#persistence` panel with buttons `#save-state`, `#load-state`, `#reset-game`, and a read-only `<textarea id=\"state-json\">` that mirrors serialized state and localStorage. Maintain the settings and progression from subtask3.\nDeliverables:\n- Keep using only `index.html`, `styles.css`, and `app.js`; ensure the persistence panel sits below the settings/level UI.\n- Extend `window.app` with `serializeState()`, `applyState(serialized)`, `resetGame()`, `getProgress()` returning `{ level, bestFit, attempts }`, and an async `mockBackendSync()` Promise that resolves with `{ synced: true, source: 'client', timestamp }`. State should autosave to `localStorage['squarefit-state']` and auto-rehydrate on load.\nRubric:\n- Save/load: after two simulated attempts, clicking `#save-state` must populate `#state-json` with JSON containing attempts and level plus write the same payload to localStorage; `serializeState()` must match this string.\n- Reset/resume: `resetGame()` clears attempts but preserves level/progress counters in `#progress` and `getProgress()`; clicking `#load-state` or `applyState()` reconstructs attempts and the last-attempt highlight exactly.\n- Backend imitation: `mockBackendSync()` resolves within 1s returning the expected object and updates a visible log or status note in the HUD.",
  "subtask5": "Query:\nLayer a diagnostics/ad sandbox using only inline data. Add a toggle `#toggle-diagnostics` that slides a right-aligned `<aside id=\"diagnostics\">` into view (260+/-6px wide, 60+/-6px from the right edge). Inside, show a table with headers `Metric` and `Value`, an ads panel `#ads` with buttons `#show-rewarded` and `#show-interstitial`, and controls to preview scenarios defined inline in `app.js` (no extra JSON files allowed).\nDeliverables:\n- Continue shipping the three main files; embed at least two scenarios in code (array of attempts with id/label/moves/target/winner) accessible to automation.\n- Extend `window.app` with `loadScenario(id)`, `summarizeScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, and `estimateHeap()`. `playScenario` returns a Promise resolving after playback and should block manual input during animation.\nRubric:\n- Scenario import: calling `loadScenario(0)` positions the target/squares per the fixture and updates HUD text; `summarizeScenario(0)` returns counts for attempts and best fit percentage.\n- Playback: `playScenario(1, { intervalMs: 220 })` replays the scenario chronologically with >=200ms spacing, re-enables manual attempts afterward, and updates `debugState().attempts`.\n- Diagnostics/ad UX: `getDiagnostics()` exposes keys `depth`, `elapsedMs`, `nodes`, and `topFits` (array); the diagnostics table lists these values and stays 260+/-6px wide at 60+/-6px from the right edge in `diagnostics.png`. Five successive `estimateHeap()` calls must be non-decreasing integers <=64000000. Clicking the ad buttons should append log text (e.g., \"rewarded shown\") to `#ads` or HUD."
}
