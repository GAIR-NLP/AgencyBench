{
  "subtask_count": 5,
  "subtask1": "Query:\nDesign a landing view for an Interactive 3D Solar System. Render a 3D viewport (`#view-3d`) beside a 2D map (`#view-2d`) plus a bottom `#planet-menu` with labelled planet buttons (Mercury through Neptune) and an `#info-panel` that can show size, spin rate, and distance. Include toggles `#toggle-3d` and `#toggle-2d` plus a primary `#start-btn` labelled `Launch Explorer`. Automatically call `window.app.initializeScene()` on load so orbit placeholders appear without user clicks.\nDeliverables (only these files):\n- `index.html` linking `styles.css` and `app.js` via relative paths and containing containers `#view-3d`, `#view-2d`, `#planet-menu`, `#info-panel`, `#toggle-3d`, `#toggle-2d`, and `#start-btn`.\n- `styles.css` styling a 16:9 hero area around 960×540 for the 3D viewport, a right-hand 2D strip or inset map, and a horizontal planet menu docked below them.\n- `app.js` exposing `window.app` with methods `initializeScene()` and `describeLayout()`; `describeLayout()` must return `{ view3d, view2d, menu, info, toggles }` where each entry includes x, y, width, height (viewport pixels). Render the planet menu using `button[data-planet]` entries for Mercury through Neptune with lowercase data values (e.g., `mercury`, `venus`, `earth`).\nRubric:\n- Layout balance: automation captures `layout.png` and expects `#view-3d` to be centered and sized 900–980px wide and 500–560px tall with `#view-2d` visibly docked on the right or as an inset occupying at least 20% of the width.\n- Navigation affordances: the `#start-btn` and both toggles are visible, legible, and reported inside `describeLayout().toggles`. Planet buttons are labelled and arranged in a docked `#planet-menu` bar.\n- Scene bootstrapping: calling `initializeScene()` twice leaves a single set of orbit placeholders and the same `describeLayout()` payload (idempotent). Orbit placeholders may be circles or stub planet nodes but must render in both views without extra interaction.",
  "subtask2": "Query:\nImplement view switching and planet selection. Toggling `#toggle-3d` or `#toggle-2d` should enable/disable the corresponding view panes, and a side-by-side comparison mode should activate when both are on. Selecting a planet from `#planet-menu` highlights it in both views and updates the `#info-panel` with spin speed, relative size, and distance text. Add a status line `#status-bar` that announces the active view and planet.\nDeliverables (only these files):\n- Continue shipping `index.html`, `styles.css`, `app.js`, with `#status-bar` placed beneath the menu.\n- Extend `window.app` with `debugState()` (returns `{ viewMode, activePlanet, compared, infoText }`) and `setActivePlanet(name)` to seed selections for automation.\nRubric:\n- Toggle handling: automation flips `#toggle-2d` then `#toggle-3d`; `debugState().viewMode` must report `\"compare\"` when both are on, `\"3d\"` when 2D is off, and `\"2d\"` when 3D is off. Screenshots in `view_switches.webm` should show one pane dimming when disabled.\n- Planet focus: clicking the first two planets updates `debugState().activePlanet` accordingly, highlights the matching buttons, and rewrites `#info-panel` text with different numeric details per planet.\n- Status text: `#status-bar` reads `3D global view` at load, mentions `2D comparison` after both toggles are on, and includes the active planet name after selection. Layout proportions from subtask1 remain intact.",
  "subtask3": "Query:\nAdd motion controls so reviewers can explore orbit speeds and playback. Include a range input `#orbit-speed` (0.1–2.0) bound to rotation speed, a `#play-tour` button to animate the system, and a subtle marker indicating the most recently updated planet. Keep prior interactions functional.\nDeliverables (only these files):\n- Continue shipping the three core files. Add the new controls beneath `#status-bar` inside a `#controls` container.\n- Extend `window.app` with `telemetry()` returning `{ playing, speed, frameCount, activePlanet }`, `setDemoKeyframes(sequence)` to preload orbit angles for automation, and `exportKeyframes()` returning the sampled keyframes array.\nRubric:\n- Speed binding: automation sets `#orbit-speed` near 0.8; `telemetry().speed` must reflect that change and remain stable while idle.\n- Playback: clicking `#play-tour` starts motion; after 1.5s `telemetry().playing` is true and `frameCount` has advanced by at least 3 frames. `exportKeyframes()` returns ≥3 entries showing evolving angles or timestamps, captured in `orbit_motion.webm`.\n- Visual cues: the most recent planet update (e.g., Earth) carries a halo or pulse, and toggles plus menu remain usable while playback runs.",
  "subtask4": "Query:\nIntroduce persistence and comparison controls without adding new files. Add buttons `#save-view`, `#load-view`, `#reset-view`, and a read-only `<textarea id=\"state-json\">` under a `#persistence` panel. Saving should serialize current view mode, active planet, compared planets, and orbit speed into the textarea and `localStorage['solar-state']`. Loading rehydrates the same state; reset clears user selections but keeps default orbit placeholders. Provide a `#compare-view` toggle to show two planets side by side when multiple are selected.\nDeliverables (only these files):\n- Keep `index.html`, `styles.css`, `app.js`; do not introduce other assets. Style the persistence panel to align with existing UI.\n- Extend `window.app` with `serializeState()`, `applyState(serialized)`, `resetScene()`, `setComparison(list)`, and `getComparison()` returning `{ list: string[], view: string }`. Ensure methods are safe to call repeatedly.\nRubric:\n- Save/restore: after selecting two planets, `#save-view` writes identical JSON into `#state-json` and `localStorage['solar-state']`; `serializeState()` mirrors that payload. Clicking `#reset-view` clears active/comparison lists, and `debugState()` reflects an empty selection while placeholders remain. `#load-view` restores the saved selection and view mode.\n- Comparison view: activating `#compare-view` displays both selected planets concurrently (either split view or stacked cards) and `getComparison().list` matches the visual order.\n- Regression: motion controls, status messaging, and layout rules from subtasks 1–3 continue to work.",
  "subtask5": "Query:\nAdd a diagnostics sidebar and scripted flyover scenarios. Provide a `#toggle-diagnostics` button that slides in an `<aside id=\"diagnostics\">` fixed to the right. The sidebar must show current metrics (depth, elapsedMs, nodes, view, topLines array) in a table with headers `Metric` and `Value`, plus controls to preview built-in scenarios. Bundle at least two scenario definitions inline in `app.js` (no extra files) with keys `id`, `label`, `planets`, `camera`, and optional `winner` label.\nDeliverables (only these files):\n- Keep the core files; embed scenario data directly in `app.js`. Sidebar width should sit around 260±6px and offset 60±6px from the right edge while open.\n- Extend `window.app` with `loadScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, `summarizeScenario(id)`, and `estimateHeap()`. `playScenario` returns a Promise resolving after animation while blocking manual clicks until done.\nRubric:\n- Scenario import: calling `loadScenario(0)` positions planets and camera per the fixture, updates banners (use `winner` if present), and logs the active planet into diagnostics. `summarizeScenario(0)` returns totals for bodies and max distances.\n- Playback: invoking `playScenario(1, { intervalMs: 220 })` replays waypoints with ≥200ms spacing and then re-enables manual toggles. Video `scenario_playback.webm` should show smooth motion.\n- Diagnostics: while the sidebar is visible, the metrics table lists depth/elapsedMs/nodes/view/topLines and stays the specified width/offset captured in `diagnostics.png`. `estimateHeap()` called five times returns non-decreasing integers ≤64000000. All expectations from subtasks 1–4 remain satisfied."
}
