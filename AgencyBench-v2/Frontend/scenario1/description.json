{
  "subtask_count": 5,
  "subtask1": "Query:\nCreate a static launch view for an interactive USA map. Render a responsive SVG map with clickable state shapes (use `data-state` on each state). Include a prominent `#render-map` button labelled `Render Map`, a `#map-container` wrapping the map, and a legend explaining state colors and pins. Automatically call `window.app.initializeMap()` on load so the map appears without manual interaction.\nDeliverables:\n- `index.html` that links `styles.css` and `app.js` via relative paths and contains `#map-container` with an `<svg>` map, `#legend`, and the `#render-map` button.\n- `styles.css` defining a 900px × 560px responsive map area centered on the page, styling the legend beneath the map and the render button.\n- `app.js` exposing `window.app` with methods `initializeMap()` and `describeLayout()`. `describeLayout()` must return an object with keys `mapBounds` (`x`, `y`, `width`, `height`), `states` (mapping codes like `\"CA\"`, `\"TX\"`, `\"NY\"` to `{ \"x\": number, \"y\": number }` viewport centers), and `pins` (array; empty is fine).\nRubric:\n- Map rendering: automation captures `layout.png` and confirms the map area is 900±6px wide and 560±6px tall, centered within ±8px horizontally and vertically. At least 10 elements with `data-state` must exist, and `describeLayout().states` must include `CA`, `TX`, and `NY` with numeric `x`/`y` values.\n- Controls placement: `describeLayout()` must report `mapBounds` roughly centered, the render button near `{ \"x\": 120±8, \"y\": 120±8 }`, and the legend’s top edge within 80±8px of the map’s bottom edge.\n- DOM contract: the page must render `#map-container` wrapping an `<svg>` with `data-state` nodes plus elements `#legend` and `#render-map`.\n- API bootstrapping: invoking `window.app.initializeMap()` twice must be idempotent, leaving exactly one map instance and a populated layout payload.",
  "subtask2": "Query:\nExtend the map so clicking a state toggles selection, starting empty. Show a status line in `#status-bar` and highlight the latest selected state with a pulsing ring (`#active-indicator`). Keep all assets from subtask1.\nDeliverables:\n- Continue shipping `index.html`, `styles.css`, and `app.js`, updating the markup to include `#status-bar` beneath the legend.\n- Extend `window.app` with `debugState()` (returning selected state codes in order and the last selected code) and `setDemoSelection(sequence)` where `sequence` is an array of state codes for automation to preload selections.\nRubric:\n- Selection order: automation clicks the states reported by `describeLayout()` for `CA`, `TX`, then attempts `TX` again. `debugState().selected` must record unique selections in order (`[\"CA\",\"TX\"]`) and refuse the duplicate while keeping `last` as `TX`.\n- Last selection halo: after the second valid click the element `#active-indicator` must surround the latest state with a 26±4px animated ring captured in `selection_pulse.webm`.\n- Status updates: `#status-bar` text must read `No state selected` at load, switch to `Selected: CA` after the first click, then `Selected: TX` when the duplicate is rejected.\n- Layout regression: the screenshot and `describeLayout()` metrics from subtask1 must remain within the same tolerances.",
  "subtask3": "Query:\nIntroduce pins and a route playback with undo/redo controls while preserving selection behavior. Add a toolbar `#controls` containing buttons `button[data-action=\"undo\"]`, `button[data-action=\"redo\"]`, and `button[data-action=\"tour\"]` displayed in that order beneath the status bar.\nDeliverables:\n- Keep `index.html`, `styles.css`, and `app.js` only. Add a `#route-banner` area to surface tour status.\n- Extend `window.app` with methods `addPin(pin)`, `listPins()`, `undo()`, `redo()`, `startTour(route, options)`, `checkCoverage()`, and `exportLog()` returning an in-memory log string (no external files).\nRubric:\n- Route scenario: automation seeds pins for `CA`, `NV`, `UT`, and `CO`, then calls `startTour` with that route. After the final step `checkCoverage()` must report those four states as visited, `#route-banner` must read `Tour complete`, and manual state clicks must be disabled during playback.\n- Replay controls: activating the toolbar buttons (undo → redo → tour) must modify the map accordingly while `tour_replay.webm` shows pins or states animating in chronological order at ≥240ms per step. Manual clicks stay blocked until the tour finishes.\n- Logging: `exportLog()` must return a multi-line string containing each visited state once plus tour start/finish markers.\n- Continuity: selection enforcement, last selection highlighting, and layout expectations from subtasks 1–2 must still hold.",
  "subtask4": "Query:\nAdd a persistence panel that saves and restores map selections and pins without losing toolbar functionality. Introduce a panel `#persistence` beneath the controls containing buttons `#save-map`, `#load-map`, and `#reset-map` plus a read-only `<textarea id=\"state-json\">`. Saving writes the current map state to the textarea and `localStorage['usa-map-state']`. Loading parses the textarea and rehydrates selections and pins. Reset clears the map but retains cumulative metrics displayed inside `#metrics` with counters `.states-selected`, `.pins-dropped`, `.routes-run`.\nDeliverables:\n- Continue shipping the three primary files. The new panel must sit below `#controls` and adopt responsive styling that matches the existing layout.\n- Extend `window.app` with `serializeState()`, `applyState(serialized)`, `resetMap()`, and `getMetrics()` returning `{ states: number, pins: number, routes: number }`. Persist the latest save so reloading the page reenacts the saved map automatically.\nRubric:\n- Save flow: after several selections and pins, `#save-map` updates `#state-json` with JSON containing `states` and `pins` arrays and writes the same payload to `localStorage['usa-map-state']`. `serializeState()` must return identical data.\n- Restore flow: invoking `resetMap()` empties the map while keeping metrics totals. Calling `applyState()` with the previously saved JSON must rebuild selections, the active indicator, and `debugState()` history exactly.\n- Metrics: when a tour completes followed by `resetMap()`, `getMetrics()` increments the `routes` count without altering state or pin totals. Visual labels in `#metrics` must reflect the same totals.\n- Regression: undo/redo/tour behavior and layout tolerances from subtasks 1–3 remain satisfied.",
  "subtask5": "Query:\nLayer a diagnostics sidebar and scripted scenarios to stress-test persistence features. Add a toggle button `#toggle-diagnostics` that slides a right-aligned `<aside id=\"diagnostics\">` into view displaying current coverage, total selections, pins, elapsed milliseconds, and a table with headers `Metric` and `Value`. Embed scenario data directly in `app.js` with at least two entries containing `id`, `label`, `states`, `pins`, and `route` fields. Provide playback controls within the sidebar to preview scenarios and inspect metrics.\nDeliverables:\n- Keep existing files only. Sidebar must reveal aggregated stats for the active map and scenario preview (e.g., coverage %, pin count, longest route) in a structured list.\n- Extend `window.app` with `loadScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, `summarizeScenario(id)`, and `estimateHeap()`. `playScenario` should return a Promise resolving after the animation completes while blocking manual clicks.\nRubric:\n- Scenario import: calling `loadScenario(0)` must select states/pins per the fixture, update the banner using the scenario label, and log the route. `summarizeScenario(0)` returns an object containing total states, total pins, and route length.\n- Playback: invoking `playScenario(1, { intervalMs: 220 })` replays the scenario in order with ≥200ms spacing, re-enabling manual clicks afterward.\n- Diagnostics: after either scenario, `getDiagnostics()` supplies keys `coverage`, `elapsedMs`, `nodes`, and `topRegions` (array). While the sidebar is visible, the table lists these values and stays 260±6px wide at 60±6px from the right edge, captured in `diagnostics.png`.\n- Stability: calling `estimateHeap()` five times in succession yields non-decreasing integers ≤64000000. All expectations from subtasks 1–4 continue to hold."
}
