{
  "subtask_count": 5,
  "subtask1": "\nQuery:\nCreate a splash screen for a browser-based 2048 puzzle. Render a centered 4x4 grid inside `#grid`, a scoreboard row with `.score-card.current` (\"Score\") and `.score-card.best` (\"Best\"), a primary `#new-game` button, and a tagline reading `Play 2048 in the browser`. Automatically call `window.game.initializeGrid()` on load so the 16 placeholder cells render without user interaction.\nDeliverables:\n- `index.html` linking `styles.css` and `app.js`, containing wrappers `#grid`, `#scoreboard`, `#new-game`, and `#tagline`.\n- `styles.css` giving the grid a 480+/-2px square layout with four equal columns, rounded cells, and styling for the scoreboard cards plus the CTA button.\n- `app.js` exposing `window.game` with methods `initializeGrid()` and `describeLayout()`. `describeLayout()` must return `{ gridSize, startButton, cards, cells }` where `cells` maps identifiers like `\"r1c1\"` to `{ \"x\": number, \"y\": number }` viewport coordinates.\nRubric:\n- Visual grid: automation captures `layout.png` and confirms `#grid` is 480+/-4px in both dimensions, centered within +/-8px horizontally, and displays exactly four columns and rows with consistent 16px gaps.\n- Controls placement: `describeLayout()` must report `startButton` roughly at `{ \"x\": 84+/-6, \"y\": 120+/-6 }` and `gridSize` describing `{ \"width\": 480+/-4, \"height\": 480+/-4 }`. `.score-card.best` must sit within 40+/-6px of `.score-card.current` when measured from their top edges.\n- DOM contract: the page must render 16 `.cell` elements, each carrying `data-cell=\"r<row>c<col>\"`, plus elements `#grid`, `#scoreboard`, `#new-game`, and `#tagline`.\n- API bootstrapping: invoking `window.game.initializeGrid()` twice must be idempotent, leaving exactly one set of 16 cells and a populated `describeLayout()` payload covering every cell.\n",
  "subtask2": "\nQuery:\nActivate the 2048 grid so arrow keys (or on-screen controls) slide numbered tiles, update scores, and announce moves via `#status-bar`. Keep everything from subtask1. Spawned tiles should animate in with a scale pulse and merged tiles should flash using `.merge-flash`. Provide deterministic hooks so automation can script board states.\nDeliverables:\n- Continue shipping `index.html`, `styles.css`, and `app.js`. Extend the markup with `#status-bar` beneath the scoreboard and four `.move-btn` buttons (up/right/down/left) for mouse-driven tests.\n- Extend `window.game` with `debugState()` returning `{ board: number[][], score: number, lastMove: string, events: Array }`, `setGridState(matrix)` to replace the board, and `setSpawnQueue(queue)` where each entry is `{ value, row, col }` consumed after every valid move.\nRubric:\n- Turn logic: automation calls `setGridState([[2,2,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]])`, focuses the document, and sends `ArrowRight`. `debugState().board[0]` must equal `[0,0,0,4]`, the score increases by 4, and `#status-bar` reads `Moved right`.\n- Spawn queue: calling `setSpawnQueue([{value:2,row:3,col:3}])` before the move must create a tile showing `2` at `r4c4` immediately after the merge and append a `{ type: 'spawn', row: 3, col: 3 }` entry to `debugState().events`.\n- Visual cue: the merged cell needs `.merge-flash` applied for at least one animation frame captured in `merge_turns.webm`, and `.cell[data-cell=\"r1c4\"]` should contain the text `4`.\n- Regression: `describeLayout()` values, DOM contract, and layout tolerances from subtask1 must still hold despite the new controls.\n",
  "subtask3": "\nQuery:\nIntroduce undo/redo controls, automatic replay, milestone detection, and logging for reviewers. When a tile reaches 2048, show `#milestone-banner` with `2048 unlocked!` and pause manual input until replay completes. Replay should animate each recorded move in order.\nDeliverables:\n- Maintain the three primary files and append `session.log` storing comma-separated entries (`timestamp,move,score,maxTile,spawn`).\n- Add a toolbar `#controls` containing buttons `button[data-action=\"undo\"]`, `button[data-action=\"redo\"]`, and `button[data-action=\"replay\"]` displayed in that order under the status bar.\n- Extend `window.game` with methods `undo()`, `redo()`, `beginReplay()`, `checkMilestone()`, `exportLog()`, and `applyScript(sequence)` where `sequence` is an array of moves like `\"left\"`.\nRubric:\n- Milestone: automation seeds a board where row 1 equals `[1024,1024,0,0]`, runs `applyScript(['left'])`, and expects `checkMilestone()` to return `2048`. `#milestone-banner` must display `2048 unlocked!` and prevent arrow inputs until replay finishes.\n- Undo/redo: clicking undo after the milestone restores the pre-merge board, while redo reapplies the merge so `debugState().board[0]` returns `[0,0,0,2048]`.\n- Replay controls: triggering `beginReplay()` produces `replay2048.webm` with moves spaced >=250ms apart and `window.game.isReplaying` stays `true` until the final frame, after which manual clicks are re-enabled.\n- Logging: `session.log` appends one line per move plus a `milestone` marker. `exportLog()` must exactly match the file contents, preserving newline order.\n",
  "subtask4": "\nQuery:\nAdd a persistence drawer so evaluators can save, load, and reset games without losing aggregate stats. Insert `#persistence` beneath the controls containing buttons `#save-run`, `#load-run`, `#reset-board`, and a read-only `<textarea id=\"state-json\">`. Saving writes serialized state to the textarea and `localStorage['2048-state']`. Loading parses the textarea to rebuild the board, score, and milestone banner. Reset clears the board but retains totals inside `#stats` with counters `.games-played`, `.best-tile`, and `.total-score`.\nDeliverables:\n- Continue shipping `index.html`, `styles.css`, `app.js`, and `session.log`. The persistence panel must adopt the same visual system as the rest of the UI.\n- Extend `window.game` with `serializeState()`, `applyState(serialized)`, `resetGame()`, and `getStats()` returning `{ gamesPlayed, bestTile, totalScore }`. Persist the latest save so refreshing the page restores the board automatically if data exists.\nRubric:\n- Save flow: after several moves, clicking `#save-run` must populate `#state-json` with JSON containing `board`, `score`, `best`, and `log` keys and write the exact payload to `localStorage['2048-state']`. `serializeState()` returns identical data.\n- Restore flow: invoking `resetGame()` empties the board but keeps `#stats` counters. Calling `applyState()` with the saved JSON rebuilds tiles, `debugState()` history, and the milestone banner exactly.\n- Stats: after `checkMilestone()` reports `2048` followed by `resetGame()`, `getStats()` must increment `.games-played` and `.best-tile` while leaving `.total-score` equal to the last score plus future runs. The DOM counters must match the returned object.\n- Regression: undo/redo/replay behavior and logging from subtask3 remain intact.\n",
  "subtask5": "\nQuery:\nLayer a diagnostics sidebar plus scripted scenarios to stress-test the persistence tooling. Add a toggle `#toggle-diagnostics` that slides a right-aligned `<aside id=\"diagnostics\">` into view showing depth, max tile, elapsed milliseconds, branching factor, and a table with headers `Metric` and `Value`. Load scenario data from `hard_cases.json` containing at least two entries with `id`, `label`, `moves`, `spawns`, and `targetTile`. Provide playback buttons within the sidebar so reviewers can preview scenarios, metrics, and capture screenshots.\nDeliverables:\n- Keep existing files and supply `hard_cases.json`. The sidebar must reveal aggregated stats for the active grid and scenario preview (e.g., highest tile per move) in a structured list.\n- Extend `window.game` with `loadScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, `summarizeScenario(id)`, and `estimateLoad()` returning a monotonic sequence of integers. `playScenario` should return a Promise resolving after animation completes while blocking manual inputs.\nRubric:\n- Scenario import: calling `loadScenario(0)` must position tiles exactly as described in the fixture, update `#milestone-banner` using `targetTile`, log the scripted moves, and expose `summarizeScenario(0)` with `totalTiles` plus `maxTile`.\n- Playback: invoking `playScenario(1, { intervalMs: 220 })` replays the scenario with >=200ms spacing, reuses undo/redo guards, and re-enables manual clicks afterward while `scenario_preview.webm` records the animation.\n- Diagnostics: after any scenario, `getDiagnostics()` supplies keys `depth`, `elapsedMs`, `maxTile`, `branching`, and `topLines` (array). While the sidebar is visible, the table stays 260+/-6px wide at 60+/-6px from the right edge, captured in `diagnostics.png`.\n- Stability: calling `estimateLoad()` five times in succession yields non-decreasing integers <=64000000. Persistence, logging, and visual rules from subtasks 1-4 must remain satisfied.\n"
}