{
  "subtask_count": 5,
  "subtask1": "Query:\nCreate a static Snake splash view that renders a centered 20×20 arena, a compact legend describing controls, and a primary CTA button `#start-btn` labeled `Launch Snake`. The grid must expose 400 cells with `data-cell=\"r<row>c<col>\"` attributes (1-indexed) so automation can target coordinates like `r10c4`. Call `window.app.initializeArena()` on load so the markup appears without user interaction and `window.app.describeArena()` returns coordinates for key UI anchors.\nDeliverables:\n- `index.html` linking `styles.css` and `app.js` via relative paths plus containers `#snake-grid`, `#legend`, `#scoreboard`, and `#start-btn`.\n- `styles.css` defining a 600px square grid with visible 1px gutters, centering the board, positioning the legend beneath it, and styling the start button plus scoreboard badges.\n- `app.js` exposing `window.app.initializeArena()` and `window.app.describeArena()`. `describeArena()` must return `{ gridSize, startButton, legend, cells }` where `cells` maps ids such as `\"r10c4\"` to `{ \"x\": number, \"y\": number }` viewport positions. Repeated calls to `initializeArena()` must be idempotent.\nRubric:\n- Grid fidelity: automation captures `arena.png` confirming the board is 600±4px wide/tall, centered within ±6px horizontally/vertically, and renders exactly 20×20 cells.\n- DOM contract: the page must render 400 elements with class `.cell` each carrying the proper `data-cell` attribute, plus elements `#snake-grid`, `#legend`, `#scoreboard`, and `#start-btn`.\n- Layout metrics: `describeArena().startButton` must report a viewport position roughly `{ \"x\": 96±8, \"y\": 96±8 }` and the legend top must sit within 80±6px of the board bottom.\n- Auto bootstrapping: invoking `window.app.initializeArena()` twice must leave a single arena instance, with `describeArena().gridSize` staying `{ rows: 20, cols: 20 }`.",
  "subtask2": "Query:\nBring the board to life: clicking `#start-btn` should spawn the snake head at the center, update `#status-bar` text, and begin movement. Provide an on-screen D-pad `#control-pad` with buttons `button[data-dir=\"up\"]`, `down`, `left`, `right` that mirror arrow-key input. Each tick advances the snake, grows on food contact, and highlights the head with `#head-indicator`. Expose `window.app.debugState()` returning `{ direction, segments, food, status }` and `window.app.setDemoPath(sequence, options)` that replays an array of direction strings (e.g., `\"ArrowRight\"`).\nDeliverables:\n- Keep `index.html`, `styles.css`, and `app.js`, adding `#status-bar` below the legend and `#control-pad` beside the start button.\n- Extend `window.app` with `debugState()` and `setDemoPath(sequence, options)` where `options.speedMs` sets tick speed.\nRubric:\n- Turn order: automation clicks the directions reported by `setDemoPath([\"ArrowRight\",\"ArrowDown\",\"ArrowDown\",\"ArrowLeft\"])` and expects `debugState().segments.length` to increment when food is consumed while ignoring illegal immediate reversals.\n- Head halo: after the scripted path, `#head-indicator` must wrap the latest head position with a 26±4px glowing ring captured inside `movement_turns.webm`.\n- Status updates: `#status-bar` text must read `Press Start` initially, switch to `Running` when the game begins, and display `Paused` if the same direction is tapped twice quickly (treated as a pause per spec).\n- Regression: layout tolerances and DOM contract from subtask1 remain satisfied.",
  "subtask3": "Query:\nIntroduce scoring, apple spawning, collision detection, and full replay telemetry. Append a toolbar `#controls` containing buttons `button[data-action=\"pause\"]`, `button[data-action=\"resume\"]`, and `button[data-action=\"replay\"]` displayed beneath the status bar. Persist each move into `session.log` as `timestamp,action,payload`. Extend `window.app` with `pause()`, `resume()`, `startReplay()`, `checkStatus()`, and `exportLog()`.\nDeliverables:\n- Continue shipping the three primary files plus `session.log` updated during play.\n- Toolbar buttons must trigger the corresponding `window.app` methods and visually reflect active/inactive states.\n- `checkStatus()` should return `{ state: \"running\"|\"game-over\", reason, score }` and `exportLog()` must mirror the `session.log` file contents exactly.\nRubric:\n- Win/loss: automation plays the scripted path `['ArrowRight','ArrowRight','ArrowDown','ArrowDown','ArrowLeft','ArrowLeft','ArrowUp','ArrowUp']`. After completion `checkStatus().state` must equal `game-over` with reason `self-hit` and `#score-value` must freeze above 0.\n- Replay controls: clicking pause→resume→replay must toggle the board appropriately while `replay_snake.webm` shows the snake retracing moves at ≥300ms per step. Manual inputs should remain disabled during replay.\n- Logging: `session.log` must record one line per tick plus control events. `exportLog()` must exactly match file bytes and contain at least nine rows for the automated run.\n- Continuity: status text, head halo, and layout expectations from subtasks 1–2 hold.",
  "subtask4": "Query:\nAdd a persistence drawer that can save/load/reset games without losing aggregate stats. Place `#persistence` beneath `#controls` with buttons `#save-state`, `#load-state`, `#reset-world` and a read-only `<textarea id=\"state-json\">`. Saving writes the serialized state to the textarea and `localStorage['snake-state']`. Loading parses the textarea to rebuild the grid, snake, score, and control states. Reset clears only the board while retaining the lifetime totals displayed in `#scoreboard` via labels `.best-score`, `.games-played`, `.longest-run`.\nDeliverables:\n- Keep existing assets and ensure the panel is responsive with styling consistent with prior sections.\n- Extend `window.app` with `serializeState()`, `applyState(serialized)`, `resetWorld()`, and `getScoreboard()` returning `{ best, games, longest }`.\n- Persist the last save so that refreshing the page replays it automatically.\nRubric:\n- Save flow: after several ticks, clicking `#save-state` must populate `#state-json` with JSON containing a `segments` array and `score`. The same payload must land in `localStorage['snake-state']` and match `serializeState()` exactly.\n- Restore flow: invoking `resetWorld()` empties the arena while keeping scoreboard totals. Calling `applyState()` with the textarea payload must restore the snake geometry, `#head-indicator`, and `debugState().segments` sequence precisely.\n- Scoreboard: when `checkStatus()` reports `game-over` followed by `resetWorld()`, `getScoreboard()` must increment `games` and potentially `best` without reducing `longest`.\n- Regression: replay, logging, and layout tolerances from subtasks 1–3 remain satisfied.",
  "subtask5": "Query:\nLayer a diagnostics sidebar plus scripted scenarios to stress persistence. Add toggle button `#toggle-diagnostics` that slides a right-aligned `<aside id=\"diagnostics\">` into view showing depth, fps, elapsed milliseconds, and a table with headers `Metric`/`Value`. Load scenario data from `tracks.json` containing entries with `id`, `label`, `path`, `apples`, and `winner` fields. Provide controls inside the sidebar to preview and play scenarios.\nDeliverables:\n- Keep existing files and ship `tracks.json`. Sidebar must show aggregated stats for the active game and current scenario preview (e.g., longest straight, apple cadence) in a structured list.\n- Extend `window.app` with `loadScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, `summarizeScenario(id)`, and `estimateHeap()`. `playScenario` returns a Promise that resolves after animation and blocks manual clicks mid-run.\nRubric:\n- Scenario import: calling `loadScenario(0)` must position the snake according to the fixture, update `#status-bar` with the provided `winner`, and write the moves to `session.log`. `summarizeScenario(0)` returns an object containing total segments and the longest streak in a single direction.\n- Playback: invoking `playScenario(1, { intervalMs: 220 })` should replay the scenario with ≥200ms spacing, respecting pause/resume guards and re-enabling manual controls afterward, recorded in `scenario_snake.webm`.\n- Diagnostics: `getDiagnostics()` must provide keys `depth`, `elapsedMs`, `fps`, and `topSegments` (array). While the sidebar is open, the table stays 260±6px wide at 60±6px from the right edge captured in `diagnostics.png`.\n- Stability: calling `estimateHeap()` five times yields non-decreasing integers ≤64000000. All expectations from subtasks 1–4 continue to hold."
}
