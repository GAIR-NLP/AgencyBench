{
  "subtask_count": 5,
  "subtask1": "Query:\nCreate a static Tic-Tac-Toe launch view that renders a centered 3×3 board with labelled axes (A–C and 1–3), a prominent `#start-btn` labelled `Start Round`, and a legend explaining the X and O markers. Automatically call `window.app.initializeBoard()` on load so the markup appears without manual interaction.\nDeliverables:\n- `index.html` that links `styles.css` and `app.js` via relative paths and contains containers `#board`, `#legend`, and `#start-btn`.\n- `styles.css` defining a 360px square grid, positioning the legend beneath the board, and styling the start button.\n- `app.js` exposing `window.app` with methods `initializeBoard()` and `describeLayout()`; the latter returns an object with keys `startButton`, `legend`, and `cells`, where `cells` maps coordinates like `\"B2\"` to `{ \"x\": number, \"y\": number }` viewport positions.\nRubric:\n- Visual grid: automation captures `layout.png` and confirms the board is exactly 360±4px wide and tall, centered within ±6px both horizontally and vertically, and shows 3×3 intersection markers.\n- Controls placement: `describeLayout()` must report `startButton` roughly at `{ \"x\": 96±6, \"y\": 96±6 }` relative to the viewport and ensure the legend top edge sits within 60±6px of the board bottom.\n- DOM contract: the page must render 9 elements with class `.intersection` each carrying `data-cell=\"<letter><number>\"`, alongside elements `#board`, `#legend`, and `#start-btn`.\n- API bootstrapping: invoking `window.app.initializeBoard()` twice must be idempotent, leaving exactly one board instance and a populated description payload.",
  "subtask2": "Query:\nExtend the board so players alternate X and O when clicking intersections, starting with X. Display a status line inside `#status-bar` and highlight the latest move with a pulsing ring. Keep all assets from subtask1.\nDeliverables:\n- Continue shipping `index.html`, `styles.css`, and `app.js`, updating the markup to include `#status-bar` beneath the legend.\n- Extend `window.app` with `debugState()` (returning move history and the current player) and `setDemoMoves(sequence)` where `sequence` is an array of `{ \"coord\": \"B2\", \"symbol\": \"X\" }` objects for automation to preload moves.\nRubric:\n- Turn order: automation clicks the coordinates reported by `describeLayout()` corresponding to `B2`, `B3`, and then attempts `B3` again. `debugState().moves` must record alternating symbols for the first two moves and refuse the third with an unchanged move list.\n- Last move halo: after the second valid move the element `#last-move-indicator` must surround the latest mark with a 26±3px animated ring captured in `moves_turns.webm`.\n- Status updates: `#status-bar` text must read `X to move` at load, switch to `O to move` after the first click, then revert to `X to move` when the duplicated coordinate is rejected.\n- Layout regression: the screenshot and describeLayout() metrics from subtask1 must remain within the same tolerances.",
  "subtask3": "Query:\nIntroduce automatic victory detection, a banner announcing the winner, undo/redo controls, and a replay feature that animates the finished game. Preserve the interactive flow from subtask2.\nDeliverables:\n- Maintain the three primary files and append a `session.log` file storing comma-separated history (`timestamp,player,coord`).\n- Add a toolbar `#controls` containing buttons `button[data-action=\"undo\"]`, `button[data-action=\"redo\"]`, and `button[data-action=\"replay\"]` displayed in that order beneath the status bar.\n- Extend `window.app` with methods `undo()`, `redo()`, `startReplay()`, `checkWinner()`, and `exportLog()` returning the log contents.\nRubric:\n- Win scenario: automation plays the sequence `A1, B1, A2, B2, A3` (X begins). After the final move `checkWinner()` must return `X`, `#winner-banner` must display `X wins!`, and further manual clicks must be disabled.\n- Replay controls: activating the toolbar buttons (undo → redo → replay) must modify the board accordingly while `replay.webm` shows marks animating in chronological order at ≥300ms per move. During replay manual clicks remain blocked until completion.\n- Logging: `session.log` must append one line per move plus replay markers (if any). `exportLog()` must match the file content exactly.\n- Continuity: turn enforcement, last move highlighting, and layout expectations from subtasks 1–2 must still hold.",
  "subtask4": "Query:\nAdd a persistence drawer that lets reviewers save and restore finished games without losing the log or replay tools. Introduce a panel `#persistence` beneath the controls containing buttons `#save-game`, `#load-game`, and `#reset-match` plus a read-only `<textarea id=\"state-json\">`. Saving writes the current match state to the textarea and `localStorage['tictactoe-state']`. Loading parses the textarea and rehydrates board, log, and indicators. Reset clears the board but retains totals for wins/draws shown inside `#scoreboard` with counters `.x-wins`, `.o-wins`, `.draws`.\nDeliverables:\n- Continue shipping the three primary files. The new panel must sit below `#controls` and adopt responsive styling that matches the existing layout.\n- Extend `window.app` with `serializeState()`, `applyState(serialized)`, `resetMatch()`, and `getScoreboard()` returning `{ x: number, o: number, draws: number }`. Persist the latest save so reloading the page reenacts the saved board automatically.\nRubric:\n- Save flow: after several moves, `#save-game` updates `#state-json` with JSON containing a `moves` array and writes the same payload to `localStorage['tictactoe-state']`. `serializeState()` must return the identical data.\n- Restore flow: invoking `resetMatch()` empties the board while keeping scoreboard totals. Calling `applyState()` with the previously saved JSON must rebuild marks, last-move halo, and `debugState()` history exactly.\n- Scoreboard: when `checkWinner()` declares a winner followed by `resetMatch()`, `getScoreboard()` increments the winner count without altering the opponent tally. Visual labels in `#scoreboard` must reflect the same totals.\n- Regression: undo/redo/replay, logging, and layout tolerances from subtasks 1–3 remain satisfied.",
  "subtask5": "Query:\nLayer a diagnostics sidebar and scripted scenarios to stress-test persistence features. Add a toggle button `#toggle-diagnostics` that slides a right-aligned `<aside id=\"diagnostics\">` into view displaying current depth, total moves, elapsed milliseconds, and a table with headers `Metric` and `Value`. Load scenario data from `hard_cases.json` containing at least two entries with `id`, `label`, `moves`, and `winner` fields. Provide playback controls within the sidebar to preview scenarios and inspect metrics.\nDeliverables:\n- Keep existing files and supply `hard_cases.json`. Sidebar must reveal aggregated stats for the active game and scenario preview (e.g., longest line, optimal forks) in a structured list.\n- Extend `window.app` with `loadScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, `summarizeScenario(id)`, and `estimateHeap()`. `playScenario` should return a Promise resolving after the animation completes while blocking manual clicks.\nRubric:\n- Scenario import: calling `loadScenario(0)` must position marks per the fixture, update the banner using `winner`, and log the moves. `summarizeScenario(0)` returns an object containing total marks and the longest contiguous run for each symbol.\n- Playback: invoking `playScenario(1, { intervalMs: 220 })` replays the scenario in order with ≥200ms spacing, reusing undo/redo state guards and re-enabling manual clicks afterward.\n- Diagnostics: after either scenario, `getDiagnostics()` supplies keys `depth`, `elapsedMs`, `nodes`, and `topLines` (array). While the sidebar is visible, the table lists these values and stays 260±6px wide at 60±6px from the right edge, captured in `diagnostics.png`.\n- Stability: calling `estimateHeap()` five times in succession yields non-decreasing integers ≤64000000. All expectations from subtasks 1–4 continue to hold."
}
