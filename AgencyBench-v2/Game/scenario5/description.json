{
  "subtask_count": 5,
  "subtask1": "Query:\nBuild a static Minesweeper command console that renders a centered 12×12 field with column labels A–L and row labels 1–12. Include a HUD strip containing `#mine-count`, `#timer`, a difficulty pill `.level-pill`, and a primary button `#start-btn` labeled `New Sweep`. The field must expose containers `#field`, `#legend`, and the HUD, and automatically call `window.app.initializeField()` on load so reviewers immediately see the grid.\nDeliverables:\n- `index.html` linking `styles.css` and `app.js` via relative paths plus containers `#field`, `#hud`, `#legend`, and `#start-btn`.\n- `styles.css` defining a 540px square grid, keeping the HUD centered above the field, and positioning the legend beneath it with muted caption text.\n- `app.js` attaching `window.app` with methods `initializeField()` and `describeField()`. `describeField()` must return `{ \"hud\": { ... }, \"legend\": { ... }, \"cells\": { \"C5\": { \"x\": number, \"y\": number } } }` so automation can map coordinates.\nRubric:\n- Field geometry: automation captures `layout.png` and checks the playable area is 540±4px square, centered within ±6px horizontally and vertically, and decorated with 12×12 clickable cells.\n- HUD contract: `describeField()` must describe `hud.startButton` near `{ \"x\": 96±8, \"y\": 96±8 }` relative to the viewport and confirm the legend top edge is within 72±6px of the field bottom.\n- DOM scaffolding: the page must render 144 elements with class `.cell` each carrying `data-cell=\"<letter><number>\"`, alongside elements `#field`, `#legend`, `#hud`, and `#start-btn`.\n- Idempotent bootstrap: calling `window.app.initializeField()` twice must leave exactly one field and yield the same `describeField()` payload.",
  "subtask2": "Query:\nLayer interactivity so clicking any unrevealed cell alternates safe counts and warning states starting with a safe reveal. Show the running status in `#status-bar` (e.g., `Cells cleared: 1 | Flags: 0`) and animate the latest action using `#last-reveal-indicator`. Keep every asset from subtask1.\nDeliverables:\n- Continue shipping `index.html`, `styles.css`, and `app.js`, updating the markup to include `#status-bar` beneath the legend.\n- Extend `window.app` with `debugField()` (returning reveal history, flag placements, and the next action) and `setDemoSequence(sequence)` where `sequence` is an array of `{ \"coord\": \"C3\", \"state\": \"clear\" }` objects that automation can preload.\nRubric:\n- Reveal order: automation clicks the coordinates reported by `describeField()` corresponding to `C3`, `D3`, then attempts `D3` again. `debugField().reveals` must record two entries labelled `clear`/`warn` (alternating) while the third click leaves the history unchanged.\n- Last reveal halo: after the second valid click the element `#last-reveal-indicator` must surround the latest cell with a 24±3px animated ring captured in `turns.webm`.\n- Status updates: `#status-bar` text must read `Cells cleared: 0 | Flags: 0` at load, switch to `Cells cleared: 1 | Flags: 0` after the first click, then remain unchanged when the duplicated coordinate is ignored.\n- Layout regression: screenshot + `describeField()` metrics from subtask1 must remain within the same tolerances.",
  "subtask3": "Query:\nDetect detonations or a cleared field, present a banner announcing the outcome, and add undo/redo/replay controls with logging. Reuse the interactive flow from subtask2.\nDeliverables:\n- Maintain the three primary files and append a `session.log` file storing comma-separated history (`timestamp,action,coord`).\n- Add a toolbar `#controls` containing buttons `button[data-action=\"undo\"]`, `button[data-action=\"redo\"]`, and `button[data-action=\"replay\"]` displayed in that order beneath the status bar.\n- Extend `window.app` with methods `undoReveal()`, `redoReveal()`, `startReplay()`, `checkStatus()`, and `exportLog()` returning the log contents.\nRubric:\n- Clear scenario: automation plays the sequence `C3, C4, D3, D4, E3, E4, F3, F4, G3`. After the final move `checkStatus()` must return `cleared`, `#status-banner` must display `Field cleared!`, and further manual clicks must be disabled.\n- Replay controls: activating the toolbar buttons (undo → redo → replay) must modify the field accordingly while `replay.webm` shows tiles animating in chronological order at ≥300ms per reveal. During replay manual clicks remain blocked until completion.\n- Logging: `session.log` must append one line per reveal plus replay markers (if any). `exportLog()` must match the file content exactly.\n- Continuity: reveal enforcement, last-action highlighting, and layout expectations from subtasks 1–2 must still hold.",
  "subtask4": "Query:\nAdd a persistence drawer that lets reviewers save and restore finished fields without losing the log or replay tools. Introduce a panel `#persistence` beneath the controls containing buttons `#save-field`, `#load-field`, and `#reset-field` plus a read-only `<textarea id=\"state-json\">`. Saving writes the current match state to the textarea and `localStorage['minesweeper-state']`. Loading parses the textarea and rehydrates the field, log, and indicators. Reset clears the board but retains totals for clears/detonations shown inside `#scoreboard` with counters `.cleared-count`, `.detonated-count`, `.abandoned-count`.\nDeliverables:\n- Continue shipping the three primary files. The new panel must sit below `#controls` and adopt responsive styling that matches the existing layout.\n- Extend `window.app` with `serializeState()`, `applyState(serialized)`, `resetField()`, and `getScoreboard()` returning `{ cleared: number, detonated: number, abandoned: number }`. Persist the latest save so reloading the page reenacts the saved field automatically.\nRubric:\n- Save flow: after several reveals, `#save-field` updates `#state-json` with JSON containing a `reveals` array and writes the same payload to `localStorage['minesweeper-state']`. `serializeState()` must return the identical data.\n- Restore flow: invoking `resetField()` empties the field while keeping scoreboard totals. Calling `applyState()` with the previously saved JSON must rebuild reveals, last-action halo, and `debugField()` history exactly.\n- Scoreboard: when `checkStatus()` declares `cleared` followed by `resetField()`, `getScoreboard()` increments the cleared count without altering detonation/abandoned tallies. Visual labels in `#scoreboard` must reflect the same totals.\n- Regression: undo/redo/replay, logging, and layout tolerances from subtasks 1–3 remain satisfied.",
  "subtask5": "Query:\nAdd a diagnostics sidebar and scripted scenarios to stress-test persistence features. Add a toggle button `#toggle-diagnostics` that slides a right-aligned `<aside id=\"diagnostics\">` into view displaying current depth, revealed tiles, elapsed milliseconds, and a table with headers `Metric` and `Value`. Load scenario data from `hard_cases.json` containing at least two entries with `id`, `label`, `moves`, `mines`, and `winner` fields. Provide playback controls within the sidebar to preview scenarios and inspect metrics.\nDeliverables:\n- Keep existing files and supply `hard_cases.json`. Sidebar must reveal aggregated stats for the active field and scenario preview (e.g., safe streaks, risk windows) in a structured list.\n- Extend `window.app` with `loadScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, `summarizeScenario(id)`, and `estimateHeap()`. `playScenario` should return a Promise resolving after the animation completes while blocking manual clicks.\nRubric:\n- Scenario import: calling `loadScenario(0)` must position tiles per the fixture, update the banner using `winner`, and log the reveals. `summarizeScenario(0)` returns an object containing total tiles revealed and the largest contiguous safe run.\n- Playback: invoking `playScenario(1, { intervalMs: 220 })` replays the scenario in order with ≥200ms spacing, reusing undo/redo state guards and re-enabling manual clicks afterward.\n- Diagnostics: after either scenario, `getDiagnostics()` supplies keys `depth`, `elapsedMs`, `nodes`, and `topLines` (array). While the sidebar is visible, the table lists these values, stays 260±6px wide, and sits 60±6px from the right edge, captured in `diagnostics.png`.\n- Stability: calling `estimateHeap()` five times in succession yields non-decreasing integers ≤64000000. All expectations from subtasks 1–4 continue to hold."
}
