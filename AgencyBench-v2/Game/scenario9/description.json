{
  "subtask_count": 5,
  "subtask1": "Query:\nCreate a static Sudoku launch view that renders a centered 9×9 grid with bold 3×3 sub-box outlines, row labels 1–9 on the left, and column labels A–I across the top. Include a prominent `#generate-btn` labelled `Generate Puzzle`, a `#legend` explaining givens versus player entries, and call `window.app.initializeGrid()` automatically on load so the markup shows without manual clicks.\nDeliverables:\n- `index.html` linking `styles.css` and `app.js` via relative paths and containing containers `#grid`, `#legend`, and `#generate-btn`.\n- `styles.css` defining a 540px square grid, centering the layout, styling the legend beneath the grid, and giving the button an elevated state.\n- `app.js` exposing `window.app` with methods `initializeGrid()` and `describeLayout()`; the latter returns keys `generateButton`, `legend`, and `cells`, where `cells` maps coordinates like `\"R1C1\"` to `{ \"x\": number, \"y\": number }` viewport positions.\nRubric:\n- Visual grid: automation captures `layout.png` and confirms the grid is exactly 540±4px wide/tall, centered within ±6px horizontally/vertically, and renders 3×3 sub-box delineations plus 81 clickable cells.\n- Controls placement: `describeLayout()` must report `generateButton` roughly at `{ \"x\": 112±6, \"y\": 92±6 }` and ensure the legend top edge sits within 72±6px below the grid bottom edge.\n- DOM contract: the page must render 81 elements with class `.cell` each carrying `data-cell=\"R{row}C{col}\"`, alongside elements `#grid`, `#legend`, and `#generate-btn`.\n- API bootstrapping: invoking `window.app.initializeGrid()` twice must be idempotent, leaving exactly one grid instance and a populated layout payload.",
  "subtask2": "Query:\nExtend the Sudoku composer so reviewers can select a cell and enter digits via both the keyboard and an on-screen number pad. The first valid entry should be `1`, then `2`, and so on based on user input, but duplicate digits violating Sudoku rules must be rejected with a status warning inside `#status-bar`. Provide a dismissible highlight element `#last-entry-indicator` that surrounds the latest accepted cell with a pulsing ring. Keep all assets from subtask1.\nDeliverables:\n- Continue shipping `index.html`, `styles.css`, and `app.js`, updating the markup to include `#status-bar` beneath the legend plus a `#number-pad` containing nine `button[data-digit]` controls.\n- Extend `window.app` with `debugState()` (returning entry history, conflicts, and the current cue) and `setDemoEntries(sequence)` where `sequence` is an array of `{ \"cell\": \"R1C1\", \"value\": 5, \"locked\": boolean }` for automation to preload givens.\nRubric:\n- Input enforcement: automation focuses `R1C1`, types `5`, then `R1C2` `6`, and finally attempts to place `6` again in `R1C1`. `debugState().entries` must show only the two valid placements, while the duplicate attempt is rejected and reported under `.conflicts`.\n- Last entry halo: after the second valid entry the element `#last-entry-indicator` must surround the latest cell with a 30±4px animated ring captured in `entries_turns.webm`.\n- Status updates: `#status-bar` text must read `Select a cell` on load, switch to `Digit placed: 5` after the first entry, then show a conflict message such as `Row already contains 6` when the duplicate is attempted.\n- Layout regression: the screenshot and describeLayout() metrics from subtask1 must remain within the same tolerances.",
  "subtask3": "Query:\nIntroduce automatic completion detection, a banner announcing the solve status, undo/redo controls, and a replay feature that animates the solving session. Preserve the interactive flow from subtask2 and start logging to `session.log`.\nDeliverables:\n- Maintain the three primary files and append a `session.log` file storing comma-separated history (`timestamp,cell,value,source`).\n- Add a toolbar `#controls` containing buttons `button[data-action=\"undo\"]`, `button[data-action=\"redo\"]`, and `button[data-action=\"replay\"]` displayed in that order beneath the status bar, plus a `#completion-banner`.\n- Extend `window.app` with methods `undo()`, `redo()`, `startReplay()`, `checkSolution()`, and `exportJournal()` returning the log contents.\nRubric:\n- Solve scenario: automation plays the sequence `R1C1, R1C2, R1C3, R1C4, R1C5, R1C6, R1C7, R1C8, R1C9` (digits are provided via demo entries). After the final entry `checkSolution()` must return `Solved`, `#completion-banner` must display `Puzzle solved!`, and further manual edits must be disabled until reset.\n- Replay controls: activating the toolbar buttons (undo → redo → replay) must modify the grid accordingly while `replay.webm` shows digits animating in chronological order at ≥300ms per move. During replay manual clicks remain blocked until completion.\n- Logging: `session.log` must append one line per entry plus replay markers (if any). `exportJournal()` must match the file content exactly.\n- Continuity: status messaging, last-entry highlighting, and layout expectations from subtasks 1–2 must still hold.",
  "subtask4": "Query:\nAdd a persistence drawer that lets reviewers save and restore partially solved puzzles without losing the log or replay tools. Introduce a panel `#persistence` beneath the controls containing buttons `#save-grid`, `#load-grid`, and `#reset-puzzle` plus a read-only `<textarea id=\"state-json\">`. Saving writes the current puzzle state to the textarea and `localStorage['sudoku-state']`. Loading parses the textarea and rehydrates digits, notes, and indicators. Reset clears the grid but retains totals for solve outcomes shown inside `#scoreboard` with counters `.solved-count`, `.invalid-count`, `.abandoned-count`.\nDeliverables:\n- Continue shipping the three primary files. The new panel must sit below `#controls` and adopt responsive styling consistent with the existing layout.\n- Extend `window.app` with `serializeState()`, `applyState(serialized)`, `resetPuzzle()`, and `getSolveStats()` returning `{ solved: number, invalid: number, abandoned: number }`. Persist the latest save so reloading the page reenacts the saved grid automatically.\nRubric:\n- Save flow: after several entries, `#save-grid` updates `#state-json` with JSON containing a `entries` array and writes the same payload to `localStorage['sudoku-state']`. `serializeState()` must return the identical data.\n- Restore flow: invoking `resetPuzzle()` empties the grid while keeping scoreboard totals. Calling `applyState()` with the previously saved JSON must rebuild digits, last-entry halo, and `debugState()` history exactly.\n- Scoreboard: when `checkSolution()` declares `Solved` followed by `resetPuzzle()`, `getSolveStats()` increments `solved` without altering other tallies. Visual labels in `#scoreboard` must reflect the same totals.\n- Regression: undo/redo/replay, logging, and layout tolerances from subtasks 1–3 remain satisfied.",
  "subtask5": "Query:\nLayer a diagnostics sidebar and scripted puzzle scenarios to stress-test persistence features. Add a toggle button `#toggle-diagnostics` that slides a right-aligned `<aside id=\"diagnostics\">` into view displaying current depth, filled cells, elapsed milliseconds, and a table with headers `Metric` and `Value`. Load scenario data from `hard_cases.json` containing at least two entries with `id`, `label`, `grid`, and `solution` fields. Provide playback controls within the sidebar to preview scenarios and inspect metrics.\nDeliverables:\n- Keep existing files and supply `hard_cases.json`. The sidebar must reveal aggregated stats for the active puzzle and scenario preview (e.g., longest chain, branching factor) in a structured list.\n- Extend `window.app` with `loadScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, `summarizeScenario(id)`, and `estimateHeap()`. `playScenario` should return a Promise resolving after the animation completes while blocking manual edits.\nRubric:\n- Scenario import: calling `loadScenario(0)` must position digits per the fixture, update the completion banner using the fixture's `label`, and log the moves. `summarizeScenario(0)` returns an object containing total givens and the longest contiguous fill for each region.\n- Playback: invoking `playScenario(1, { intervalMs: 220 })` replays the scenario in order with ≥200ms spacing, reusing undo/redo state guards and re-enabling manual edits afterward.\n- Diagnostics: after either scenario, `getDiagnostics()` supplies keys `depth`, `elapsedMs`, `nodes`, and `topLines` (array). While the sidebar is visible, the table lists these values and stays 260±6px wide at 60±6px from the right edge, captured in `diagnostics.png`.\n- Stability: calling `estimateHeap()` five times in succession yields non-decreasing integers ≤64000000. All expectations from subtasks 1–4 continue to hold."
}
