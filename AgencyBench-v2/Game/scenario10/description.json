{
  "subtask_count": 5,
  "subtask1": "Query:\nDesign a Fruit Ninja training launch screen that renders a 900×540 `#playfield` with five illuminated slicing lanes labelled `L1–L5`, a neon headline, and a large `#start-btn` reading `Start slicing`. The layout must include a stacked `#legend` explaining fruit colors plus a minimalist HUD (`#hud`) that shows score, combo meter, and timer placeholders. Automatically call `window.app.initializeField()` so all SVG/canvas primitives appear on load without manual input, and expose `window.app.describeLayout()` that reports the location of the play button, legend, and each lane hotspot.\nDeliverables:\n- `index.html` linking `styles.css` and `app.js` via relative paths and containing `#playfield`, `#legend`, `#hud`, and `#start-btn` containers.\n- `styles.css` that fixes the playfield to 900×540px, centers the scene, creates five evenly spaced laser lanes, and styles the HUD/legend panels with futuristic typography.\n- `app.js` attaching `window.app` with `initializeField()` (idempotent) and `describeLayout()`. `describeLayout()` must return `{ playButton, legend, targets }` where `targets` is a dictionary mapping strings like `\"L3\"` to `{ \"x\": number, \"y\": number }` viewport coordinates used for automation.\nRubric:\n- Scene composition: automation captures `layout.png` and confirms `#playfield` is 900±6px wide, 540±6px tall, horizontally centered within ±6px, and rendered with exactly five `.lane` children carrying `data-lane=\"L1\"…\"L5\"`.\n- HUD + CTA placement: `describeLayout().playButton` must sit roughly 90±10px beneath the field midpoint, while `legend` should be anchored within 80±10px below the playfield edge. The DOM must include `#playfield`, `#legend`, `#hud`, and `#start-btn`.\n- Targets contract: `describeLayout().targets` must expose five entries `L1…L5` with finite numbers so sandbox clicks can succeed.\n- Bootstrap: calling `window.app.initializeField()` twice cannot duplicate lanes or HUD content; the method must simply ensure the scene exists.",
  "subtask2": "Query:\nAdd interactive slicing so the automation can simulate blades. Each time a target lane (`L1–L5`) is clicked, spawn an animated fruit, award points, alternate blade colors (red/blue), and highlight the most recent slice with a pulsing halo `#last-slice-indicator`. Invalid duplicate slices (clicking the same lane while the fruit is still active) must be ignored. Display the current message inside `#status-bar` positioned beneath the legend.\nDeliverables:\n- Keep `index.html`, `styles.css`, `app.js` and extend the markup with `#status-bar`.\n- `window.app` must now expose `debugState()` returning `{ score, combo, laneHistory, blade }` and `setDemoSlices(sequence)` which accepts an array of `{ \"lane\": \"L3\", \"blade\": \"red\" }` objects to pre-seed fruits.\nRubric:\n- Turn logic: automation clicks the coordinates reported for `L3`, `L4`, then attempts `L4` again. `debugState().laneHistory` must record only the first two unique slices with alternating blade colors, and the third click must leave history unchanged while emitting a validation message.\n- Halo accuracy: after the second valid slice, `#last-slice-indicator` must surround the latest fruit with a 24–30px animated ring visible in `slices_turns.webm`.\n- Status flow: `#status-bar` should read `Blades idle` on load, switch to `Combo building` after the first slice, and update to `Lane already cleared` when the duplicate lane is rejected.\n- Layout guardrails: playfield size/position and describeLayout() tolerances from subtask1 must remain satisfied.",
  "subtask3": "Query:\nLayer combo detection, bomb hazards, and a replayable slice history. Winning here means chaining five valid slices without hitting a bomb. Append a ribbon `#controls` containing `button[data-action=\"undo\"]`, `button[data-action=\"redo\"]`, and `button[data-action=\"replay\"]` under the status bar. Persist every slice into `session.log` as `timestamp,lane,result` and expose `window.app.undo()`, `redo()`, `startReplay()`, `checkCombo()`, and `exportLog()`.\nDeliverables:\n- Continue shipping the core files plus `session.log`.\n- Replay mode should animate fruits in chronological order at ≥300ms per slice, disable manual input during playback, and display a `#combo-banner` that announces `Perfect combo!` when `checkCombo()` detects five clean slices. Bomb collisions should render `#combo-banner` as `Bomb triggered`.\nRubric:\n- Combo scenario: automation enqueues the sequence `L2, L3, L4, L5, L1` (all valid). After the final move `checkCombo()` must return `Perfect combo`, `#combo-banner` displays `Perfect combo!`, and further clicks are disabled until `undo()` or `reset` is issued.\n- Replay controls: pressing undo → redo → replay must update fruit placements accordingly while `combo_replay.webm` shows animated playback lasting at least 1.5s. During replay, manual clicks remain blocked.\n- Logging: `session.log` must have one row per slice plus any replay markers. `exportLog()` must match the literal file contents, including timestamps.\n- Continuity: scoring, halo behavior, and describeLayout contract from subtasks 1–2 cannot regress.",
  "subtask4": "Query:\nIntroduce persistent training archives. Add a drawer `#persistence` beneath the controls with buttons `#save-run`, `#load-run`, and `#reset-run` followed by a read-only `<textarea id=\"state-json\">`. Saving should serialize the current run into the textarea and `localStorage['fruitninja-state']`. Resetting clears the playfield but tracks totals in `#scoreboard` where `.perfect`, `.fails`, and `.combos` display counts. Loading must rehydrate fruits, halo, log, and combo banners.\nDeliverables:\n- Maintain previous files; style the persistence drawer to align with the HUD. Ensure `window.app` adds `serializeRun()`, `applyRun(serialized)`, `resetRun()`, and `getRunSummary()` returning `{ perfect, fails, combos }`. The latest save must reload automatically when the page refreshes.\nRubric:\n- Save flow: after a few slices, clicking `#save-run` should update `#state-json` with JSON containing a `slices` array and persist the same string to `localStorage['fruitninja-state']`. `serializeRun()` must return identical data.\n- Restore flow: invoking `resetRun()` empties the playfield while keeping scoreboard totals intact. Calling `applyRun()` with the saved payload must re-create fruits, halo, `debugState()` history, and `session.log`.\n- Scoreboard: when `checkCombo()` reports a perfect combo followed by `resetRun()`, `getRunSummary()` must increment `.perfect` without touching `.fails` or `.combos`. Visible labels in `#scoreboard` must match the returned totals.\n- Regression: undo/redo/replay, logging, and playfield layout rules from subtasks 1–3 must still hold.",
  "subtask5": "Query:\nBuild a diagnostics sidebar for scenario playback. Add a toggle button `#toggle-diagnostics` that slides in a right-aligned `<aside id=\"diagnostics\">` showing current depth, total fruits, elapsed milliseconds, and a table with headers `Metric`/`Value`. Load scenario fixtures from `hard_cases.json` containing at least two entries with `id`, `label`, `slices`, `hazards`, and `winner`. The sidebar must list scenario summaries and expose playback controls.\nDeliverables:\n- Keep the existing files and add `hard_cases.json`. Inside the sidebar surface aggregated stats (longest combo, bombs avoided, blade usage) plus preview buttons.\n- Extend `window.app` with `loadScenario(id)`, `playScenario(id, options)`, `getDiagnostics()`, `summarizeScenario(id)`, and `estimateHeap()`. `playScenario` should return a Promise that resolves after animations finish while locking manual input.\nRubric:\n- Scenario import: calling `loadScenario(0)` must position fruits per the fixture, update `#combo-banner` using the scenario's `winner`, and append entries to the log. `summarizeScenario(0)` returns an object with total fruits and longest combo per blade color.\n- Playback: invoking `playScenario(1, { intervalMs: 220 })` replays that fixture in chronological order with ≥200ms spacing, pauses user clicks, and resumes them at completion; captured in `scenario_replay.webm`.\n- Diagnostics: after either scenario, `getDiagnostics()` must expose `depth`, `elapsedMs`, `nodes`, and `topLines` (array). When the sidebar is visible, the metrics table stays 260±6px wide and 60±6px from the right edge, recorded in `diagnostics.png`.\n- Stability: calling `estimateHeap()` five times consecutively yields non-decreasing integers ≤64000000. Requirements from subtasks 1–4 remain enforced."
}
